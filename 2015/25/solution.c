/* solution.c -- aoc 2015 25 -- troy brumley */

/*
 * The first code is 20151125. After that, each code is generated by
 * taking the previous one, multiplying it by 252533, and then keeping
 * the remainder from dividing that value by 33554393.
 *
 * seed 20151125
 *
 * times 252533
 * mod 33554393
 */

/*
 *
 * So, to find the second code (which ends up in row 2, column 1),
 * start with the previous value, 20151125. Multiply it by 252533 to
 * get 5088824049625. Then, divide that by 33554393, which leaves a
 * remainder of 31916031. That remainder is the second code.
 *
 * Enter the code at row 2981, column 3075.
 *
 *    |  1   2   3   4   5   6 <- r
 * ---+---+---+---+---+---+---+
 *  1 |  1   3   6  10  15  21
 *  2 |  2   5   9  14  20
 *  3 |  4   8  13  19
 *  4 |  7  12  18
 *  5 | 11  17
 *  6 | 16
 *  ^
 *  |
 *  c
 *
 * rn = n(n+1)/2            6 * 7 / 2 = 21
 *
 * 3075 * 3076 / 2 = 4729350
 *
 * cn = ?
 *
 * cn = rn - (r - 1)
 *
 * c 2981 = rn - (2980)
 *
 * c 2981 = 2981 * ( 2982) / 2 - 2980
 *
 * c 6 = 6 * 7 - (6 - 1) =
 *
 * c 2981 = 4441691
 * r 2981 = 4444671
 *
 * c 3075 = 9458700
 * r 3075 =
 */

/*
 *    |    1         2         3         4         5         6
 * ---+---------+---------+---------+---------+---------+---------+
 *  1 | 20151125  18749137  17289845  30943339  10071777  33511524
 *  2 | 31916031  21629792  16929656   7726640  15514188   4041754
 *  3 | 16080970   8057251   1601130   7981243  11661866  16474243
 *  4 | 24592653  32451966  21345942   9380097  10600672  31527494
 *  5 |    77061  17552253  28094349   6899651   9250759  31663883
 *  6 | 33071741   6796745  25397450  24659492   1534922  27995004
 *
 */

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#include "solution.h"

#define TXBSTR_IMPLEMENTATION
#include "txbstr.h"

/*
 * i tried several approaches, and using the sequencing of the
 * locations along the diagonal looked interesting until i realized
 * i'd still have to iterate over all the codes anyway.
 *
 * leaving here for reference, but they weren't used in my solution.
 *
 * endpoints of the diagonal for triangular number 'n'. ie, what is
 * the number in our series at n,1 (the beginning), and 1,n (the end).
 */

inline unsigned long
diag_end(int n)
{
	return n * (n + 1) / 2;
}
inline unsigned long
diag_begin(int n)
{
	return diag_end(n) - (n - 1);
}

/*
 * next security code in the sequence.
 */

inline unsigned long
next_code(unsigned long code)
{
	return (code *FACTOR) % DIVISOR;
}

/*
 * given a row and column in the triangular number grid of security
 * codes, return the code value.
 */

unsigned long
code_at(
        int row,
        int col
)
{
	unsigned long code;
	code = SEED;
	int r = 1;
	int c = 1;
	do {
		if (r == row && c == col)
			break;
		r -= 1;
		c += 1;
		if (r == 0) {
			r = c;
			c = 1;
		}
		code = next_code(code);
	} while (true);
	return code;
}

/*
 * part one:
 *
 */

int
part_one(
        const char *fname
)
{

	FILE *ifile = fopen(fname, "r");
	if (!ifile) {
		printf("could not open file: %s\n", fname);
		return EXIT_FAILURE;
	}

	char iline[INPUT_LEN_MAX];
	if (!fgets(iline, INPUT_LEN_MAX - 1, ifile)) {
		printf("error reading input file: %s\n", fname);
		return EXIT_FAILURE;
	}
	const char* lower = "abcdefghijklmnopqrstuvwxyz";
	const char* upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const char* other = ", \n.;:";
	char *delims = malloc(strlen(lower) + strlen(upper) + strlen(other) + 1);
	strcpy(delims, lower);
	strcat(delims, upper);
	strcat(delims, other);

	const char **tokens = split_string(iline, delims);

	if (!tokens[1] || !tokens[2]) {
		printf("error: input should contain two numbers: %s\n", iline);
		return EXIT_FAILURE;
	}

	int row = strtol(tokens[1], NULL, 10);
	int col = strtol(tokens[2], NULL, 10);
	unsigned long code = code_at(row, col);

	printf("part one: %lu\n", code);

	fclose(ifile);
	return EXIT_SUCCESS;
}


/*
 * part two:
 *
 */

int
part_two(
        const char *fname
)
{
	printf("part two: a freebie\n");
	return EXIT_SUCCESS;
}
